--- examples/derived_vars.f90.omp_ast_tmp.omp_line_all.omp_line_all.f90	2025-11-17 00:20:56
+++ examples/derived_vars.f90.omp_ast_tmp.omp_line_all.omp_ast_all.f90	2025-11-17 00:20:56
@@ -23,13 +23,15 @@
     ALLOCATE(obj % data_arr(n), obj % prod_arr(n))
     INTEGER :: apf_tmp_i(SIZE(obj % data_arr(i)))
     apf_tmp_i = obj % data_arr(i)
+    !$omp parallel do private(i) lastprivate(apf_tmp_i) schedule(static)
     !$omp parallel do private(i) schedule(static)
-    ! 初始化原始数据数组（1到n的平方）
-!$omp parallel do private(i) lastprivate(apf_tmp_i) schedule(static)
+      ! 初始化原始数据数组（1到n的平方）
+      !$omp parallel do private(i) lastprivate(apf_tmp_i) schedule(static)
       DO i = 1, n
       apf_tmp_i = REAL(i ** 2)
     END DO
     !$omp end parallel do
+    !$omp end parallel do
     obj % data_arr(i) = apf_tmp_i
     obj % sum_val = 0.0
     ! 归约变量初始化
@@ -41,18 +43,16 @@
 
     ! 对自定义类型成员执行归约计算和依赖赋值
     SUBROUTINE process_obj(obj)
-REAL :: apf_tmp_data_arr
-REAL :: apf_tmp_prod_arr
-REAL :: apf_tmp_data_arr
-REAL :: apf_tmp_data_arr
-REAL :: apf_tmp_prod_arr
-REAL :: apf_tmp_sum_val
-REAL :: apf_tmp_data_arr
-REAL :: apf_tmp_max_val
-REAL :: apf_tmp_prod_arr
-REAL :: apf_tmp_data_arr
-REAL :: apf_tmp_data_arr
-REAL :: apf_tmp_sum_val
+    REAL :: apf_tmp_data_arr
+    REAL :: apf_tmp_data_arr
+    REAL :: apf_tmp_prod_arr
+    REAL :: apf_tmp_sum_val
+    REAL :: apf_tmp_data_arr
+    REAL :: apf_tmp_max_val
+    REAL :: apf_tmp_prod_arr
+    REAL :: apf_tmp_data_arr
+    REAL :: apf_tmp_data_arr
+    REAL :: apf_tmp_sum_val
     TYPE(MyType), INTENT(INOUT) :: obj
     INTEGER :: i, n
     TYPE(MyType) :: temp_obj
@@ -63,51 +63,24 @@
     temp_obj % sum_val = 0.0
     temp_obj % max_val = - HUGE(0.0)
     REAL :: apf_tmp_sum_val
-    apf_tmp_sum_val = obj % sum_val
-    !$omp parallel do private(i) reduction(+:apf_tmp_sum_val) schedule(static)
-
-      ! 1. 标量归约：求和（仅累加正数，条件归约）
-apf_tmp_sum_val = obj % sum_val
-apf_tmp_data_arr = obj % data_arr
-      !    sum_val 是归约变量（多次写入，输出依赖）
-!$omp parallel do private(i) reduction(+:apf_tmp_sum_val) schedule(static)
-      DO i = 1, n
-      IF (apf_tmp_data_arr(i) > 5.0) THEN
-        ! 条件筛选
-        apf_tmp_sum_val = apf_tmp_sum_val + apf_tmp_data_arr(i)
-        ! 归约：输出依赖（i-1 → i）
-      END IF
-    END DO
-    !$omp end parallel do
-obj % data_arr = apf_tmp_data_arr
-obj % sum_val = apf_tmp_sum_val
-    obj % sum_val = apf_tmp_sum_val
-
-      ! 2. 数组归约：乘积（prod_arr(i) 是前i个元素的乘积）
-apf_tmp_data_arr = obj % data_arr
-apf_tmp_prod_arr = obj % prod_arr
-apf_tmp_prod_arr = obj % prod_arr
-      !    流依赖：prod_arr(i) 依赖 prod_arr(i-1)
-      DO i = 1, n
-      IF (i == 1) THEN
-        apf_tmp_prod_arr(i) = apf_tmp_data_arr(i)
-        ! 初始值
+    IF (i == 1) THEN
+      apf_tmp_prod_arr(i) = apf_tmp_data_arr(i)
+      ! 初始值
       ELSE
-        apf_tmp_prod_arr(i) = apf_tmp_prod_arr(i - 1) * apf_tmp_data_arr(i)
-        ! 流依赖（i-1 → i）
-apf_tmp_prod_arr = apf_tmp_prod_arr
-      END IF
-obj % prod_arr = apf_tmp_prod_arr
-    END DO
+      apf_tmp_prod_arr(i) = apf_tmp_prod_arr(i - 1) * apf_tmp_data_arr(i)
+      ! 流依赖（i-1 → i）
+      apf_tmp_prod_arr_2 = apf_tmp_prod_arr
+    END IF
     REAL :: apf_tmp_max_val
     apf_tmp_max_val = obj % max_val
     !$omp parallel do private(i) schedule(static)
 
-      ! 3. 标量归约：最大值（跟踪全局最大值）
-apf_tmp_max_val = obj % max_val
-apf_tmp_data_arr = obj % data_arr
-      !    输出依赖：max_val 可能被多次更新
-!$omp parallel do private(i) schedule(static)
+    ! 3. 标量归约：最大值（跟踪全局最大值）
+    apf_tmp_max_val = obj % max_val
+    apf_tmp_data_arr = obj % data_arr
+    !$omp parallel do private(i) lastprivate(apf_tmp_max_val) schedule(static)
+    !    输出依赖：max_val 可能被多次更新
+      !$omp parallel do private(i) schedule(static)
       DO i = 1, n
       IF (apf_tmp_data_arr(i) > apf_tmp_max_val) THEN
         apf_tmp_max_val = apf_tmp_data_arr(i)
@@ -115,49 +88,60 @@
       END IF
     END DO
     !$omp end parallel do
-obj % data_arr = apf_tmp_data_arr
-obj % max_val = apf_tmp_max_val
+    !$omp end parallel do
+    obj % data_arr = apf_tmp_data_arr
     obj % max_val = apf_tmp_max_val
+    obj % max_val = apf_tmp_max_val
     INTEGER :: apf_tmp_i(SIZE(temp_obj % data_arr(i)))
     apf_tmp_i = temp_obj % data_arr(i)
 
-      ! 4. 依赖赋值：基于当前对象成员给临时对象赋值（跨对象依赖）
-apf_tmp_sum_val = obj % sum_val
-apf_tmp_prod_arr = obj % prod_arr
-      !    流依赖：temp_obj 成员依赖 obj 成员
-!$omp parallel do private(i) lastprivate(apf_tmp_i) schedule(static)
+    ! 4. 依赖赋值：基于当前对象成员给临时对象赋值（跨对象依赖）
+    apf_tmp_sum_val = obj % sum_val
+    apf_tmp_prod_arr = obj % prod_arr
+    !$omp parallel do private(i) firstprivate(apf_tmp_sum_val) lastprivate(apf_tmp_i) schedule(static)
+    !    流依赖：temp_obj 成员依赖 obj 成员
+      !$omp parallel do private(i) lastprivate(apf_tmp_i) schedule(static)
       DO i = 1, n
       apf_tmp_i = apf_tmp_prod_arr(i) + apf_tmp_sum_val
       ! 流依赖（obj → temp_obj）
     END DO
     !$omp end parallel do
+    !$omp end parallel do
     temp_obj % data_arr(i) = apf_tmp_i
 
-apf_tmp_data_arr = obj % data_arr
-apf_tmp_data_arr = obj % data_arr
-      ! 5. 自依赖赋值：当前对象数组元素依赖自身前序元素（含步长2的跨迭代依赖）
+    apf_tmp_data_arr = obj % data_arr
+    INTEGER, ALLOCATABLE :: apf_tmp_i_2(:)
+    REAL :: apf_tmp_data_arr_2
+    ALLOCATE(apf_tmp_i_2(SIZE(apf_tmp_data_arr % i)))
+    apf_tmp_i_2 = apf_tmp_data_arr % i
+    apf_tmp_data_arr_2 = obj % data_arr
+    ! 5. 自依赖赋值：当前对象数组元素依赖自身前序元素（含步长2的跨迭代依赖）
       DO i = 3, n, 2
       ! 步长为2：i=3,5,7...
       apf_tmp_data_arr(i) = apf_tmp_data_arr(i - 2) * 0.5
       ! 流依赖（i-2 → i）
-apf_tmp_data_arr = apf_tmp_data_arr
-obj % data_arr = apf_tmp_data_arr
+      apf_tmp_data_arr_2 = apf_tmp_data_arr
     END DO
+    apf_tmp_data_arr % i = apf_tmp_i_2
+    obj % data_arr = apf_tmp_data_arr_2
+    DEALLOCATE(apf_tmp_i_2)
     INTEGER :: apf_tmp_i_2(SIZE(obj % prod_arr(i)))
     apf_tmp_i_2 = obj % prod_arr(i)
     !$omp parallel do private(i) schedule(static)
 
-apf_tmp_data_arr = obj % data_arr
-      ! 6. 输出依赖：同一元素被多次写入（覆盖赋值）
-!$omp parallel do private(i) lastprivate(apf_tmp_i_2) schedule(static)
+    apf_tmp_data_arr = obj % data_arr
+    !$omp parallel do private(i) lastprivate(apf_tmp_i_2) schedule(static)
+    ! 6. 输出依赖：同一元素被多次写入（覆盖赋值）
+      !$omp parallel do private(i) lastprivate(apf_tmp_i_2) schedule(static)
       DO i = 1, n
       apf_tmp_i_2 = 2.0 * apf_tmp_data_arr(i)
       ! 输出依赖（与步骤2的prod_arr(i)冲突）
     END DO
     !$omp end parallel do
+    !$omp end parallel do
     obj % prod_arr(i) = apf_tmp_i_2
 
     DEALLOCATE(temp_obj % data_arr, temp_obj % prod_arr)
   END SUBROUTINE process_obj
 
-END MODULE custom_type_mod
+END MODULE custom_type_mod
\ No newline at end of file
